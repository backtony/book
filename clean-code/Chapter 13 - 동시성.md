## 목차
- [Intro](#1)
- [동시성이 필요한 이유](#2)
- [미신과 오해](#3)
- [동시성 방어](#4)
	- [단일 책임 원칙](#5)
    - [따름 정리: 자료 범위를 제한하라](#6)
    - [따름 정리: 자료 사본을 사용하라](#7)
    - [따름 정리: 스레드는 가능한 독립적으로 구현하라](#8)
	- [라이브러리를 이해하라](#9)
    - [Atomic](#10)
    - [다중 스레드 환경에서 안전하지 않은 클래스](#11)
- [실행 모델을 이해하라](#12)
    - [생산자-소비자](#13)
    - [읽기-쓰기](#14)
    - [식사하는 철학자들](#15)
- [동기화하는 메서드 사이에 존재하는 의존성을 이해하라](#16)
- [동기화하는 부분을 작게 만들어라](#17)
- [올바른 종료 코드는 구현하기 어렵다](#18)
- [스레드 코드 테스트하기](#19)
    - [말이 안되는 실패는 잠정적인 스레드 문제로 취급하라](#20)
    - [다중 스레드를 고려하지 않은 순차 코드부터 제대로 돌게 만들자](#21)
    - [다중 스레드를 쓰는 코드 부분을 다양한 환경에 쉽게 끼워 넣을 수 있게 스레드 코드를 구현하라](#22)
    - [다중 스레드를 쓰는 코드 부분을 상황에 맞게 조율할 수 있게 작성하라](#23)
    - [프로세서 수보다 많은 스레드를 돌려보라](#24)
    - [다른 플랫폼에서도 돌려보라](#25)
    - [코드에 보조 코드를 넣어 돌려라. 강제로 실패를 일으키게 해보라](#26)
- [결론](#27)    

---


## Intro <a name = "1"></a>
단일 스레드에서 동작하는 코드는 작성하기 쉽다.  
잘 동작하는 "것처럼" 보이는 멀티 스레드 코드를 작성하기도 쉽다.  
이는 부하를 받기 전까진 멀쩡하게 돌아간다.  
이 장에서는 여러 스레드를 동시에 돌리는 이유를 논하고 동시에 돌리는 어려움도 논한다.  
이런 어려움에 대처하고 깨끗한 코드를 작성하는 방법과 테스트하는 방법을 소개한다.  
<br>

## 동시성이 필요한 이유? <a name = "2"></a>
동시성은 단일 스레드에서 엮여 있던 "무엇을 할 것인가"와 "언제 끝날 것인가"간의 의존성을 해소시켜 준다.  
이는 구조 개선과 처리량에 도움을 줄 수 있다.  
구조 개선의 좋은 예는 Servlet 모델일 것이다.  
이론적으로, Servlet 개발자는 요청을 개별적으로 처리하는 데에만 신경을 쓰며 요청 큐를 직접 관리하는 부담을 덜 수 있다.  
물론, Servlet이 제공하는 의존성의 해소는 완벽하지 않지만 Servlet이 제공하는 구조적인 이점은 그 자체로 가치가 있다.  
한 유저의 요청을 처리하는 데에 1초가 필요한 시스템을 생각해 보자.  
이 시스템은 적은 유저가 사용할 경우 그럭저럭 괜찮은 퍼포먼스를 보여줄 것이다.  
하지만 유저가 늘어남에 따라 모든 유저는 자신보다 먼저 도착한 요청이 끝날 때까지 기다려야만 한다.  
이러한 경우 동시성이 여러 유저를 동시에 처리함으로써 처리량을 향상시킬 수 있다.  

<br>

## 미신과 오해 <a name = "3"></a>
+ 동시성은 항상 성능을 높여준다?
    - 동시성은 항상이 아니라 __때로__ 성능을 높여준다.  
    - 대기 시간이 아주 길어 여러 스레드가 프로세서를 공유할 수 있거나 여러 프로세서가 동시에 처리할 독립적인 계산이 충분히 많은 경우에만 성능이 높아진다.  
+ 동시성을 구현해도 설계는 변하지 않는다?
    - 단일 스레드와 다중 스레드 시스템은 설계가 판이하게 다르며 일반적으로 __무엇과 언제를 분리하면 시스템 구조가 크게 달라진다.__
+ 웹 또는 EJB컨테이너를 사용하면 동시성을 이해할 필요가 없다?
    - 컨테이너가 어떻게 동작하는지, 동시 수정과 데드락 같은 문제는 어떻게 해결하는지에 대해 알아야 한다.

<br>

반대로 다음은 동시성과 관련된 __타당한 생각__ 이다.
+ 동시성은 다소 부하를 유발한다.
+ 동시성은 복잡하다.
+ 일반적으로 동시성 버그는 재현하기 어렵다.
+ 동시성을 구현하려면 흔히 근본적인 설계 전략을 재고해야 한다.

<br>

## 동시성 방어 <a name = "4"></a>
지금부터 동시성 코드가 일으키는 문제로부터 시스템을 방어하는 원칙과 기술을 소개한다.  

### 단일 책임 원칙(SRP) <a name = "5"></a>
동시성은 복잡성 하나만으로도 따로 분리할 이유가 충분하다.  
즉, 동시성 관련 코드는 다른 코드와 분리해야 된다는 뜻이다.  

### 따름 정리 : 자료 범위를 제한하라 <a name = "6"></a>
다중 스레드 환경에서는 객체 하나를 공유한 후 동일 필드를 수정하던 두 스레드가 서로 간섭하여 예상치 못한 결과를 내놓게 될때가 있다.  
이런 문제를 해결하는 방안으로는 공유 객체를 사용하는 코드 내 __임계영역(critical section)을 synchronized 키워드로 보호__ 하라고 권장한다.  
임계 영역의 수는 가능한 적게 만들어야 하며, 이를 어기면 다음과 같은 문제가 발생한다.
+ 보호할 임계영역을 빼먹는다. 그래서 공유 자료를 수정하는 모든 코드가 망가진다.
+ 모든 임계영역을 올바로 보호했는지 확인하느라 같은 노력을 반복한다.
+ 그렇지 않아도 찾아내기 어려운 버그가 더 찾기 어려워진다.

따라서, __자료를 캡슐화하고 공유자료를 최대한 줄여라__  

### 따름 정리 : 자료 사본을 사용하라 <a name = "7"></a>
공유 자료를 줄이려면 처음부터 공유하지 않는 방법이 가장 좋다.  
어떤 경우에는 객체를 복사해 __읽기 전용__ 으로 사용하는 방법도 가능하다.  
어떤 경우에는 각 스레드가 객체를 복사해 사용한 후 사본에서 결과를 가져오는 방법도 가능하다.  
공유 객체를 피하는 방법이 있다면 코드가 문제를 일으킬 가능성도 아주 낮아진다.  
객체를 복사하는 시간과 부하가 걱정될 수도 있겠지만, 사본으로 동기화를 피할 수 있다면 내부 잠금을 없애 절약한 수행 시간이 사본 생성과 가비지 컬렉션에 드는 부하를 상쇄할 가능성이 크다.  

### 따름 정리 : 스레드는 가능한 독립적으로 구현하라 <a name = "8"></a>
스레드 코드를 공유 자원을 사용하지 않는 독립된 세계로 만든다면 동기화 문제는 없어지게 된다.  
모든 정보는 비공유 출처에서 가져오며 로컬 변수에 저장하게 되면 동기화 문제를 일으킬 가능성은 전무하다.  

### 라이브러리를 이해하라 <a name = "9"></a>
자바 5부터 동시성 측면에서 이전 버전보다 많이 나아졌다.  
자바 5이상으로 스레드 코드를 구현한다면 다음을 고려하라
+ 스레드 환경에서 안전한 컬렉션을 사용한다.
+ 서로 무관한 작업을 수행할 때는 executor 프레임워크를 사용한다.
+ 가능하다면 스레드가 차단되지 않는 방법을 사용한다.
+ 일부 클래스 라이브러리는 스레드에 안전하지 못하다.

java.util.concurrent 패키지가 제공하는 클래스는 다중 스레드 환경에서 사용해도 안전하며 성능도 좋다.  
실제로 ConcurrentHashMap은 동시 읽기/쓰기를 지원하면서 거의 모든 상황에서 HashMap보다 성능이 좋다.  
자바 5에는 좀 더 복잡한 동시성 설계를 지원하고자 클래스들이 추가되었다.  

Name|Description
---|---
ReentrantLock|한 메서드에서 잠그고 다른 메서드에서 푸는 락
Semaphore|전형적인 세마포로 개수(count)가 있는 락
CountDownLatch|지정한 수만큼 이벤트가 발생하고 나서야 대기 중인 스레드를 모두 해제하는 락으로 모든 스레드에게 동시에 공평하게 시작할 기회를 부여

__권장사항 : 언어가 제공하는 클래스를 검토하고 자바에서는 java.util.concurrent, java.util.concurrent.atomic, java.util.concurrent.locks를 익혀라__  

### Atomic <a name = "10"></a>
자바 5에서는 AtomicBoolean, AtomicInteger, AtomicReference를 포함한 여러 새로운 클래스를 제공한다.  
이는 다중 스레드 환경에서 값을 안전하게 갱신한다.  
```java
// 기본 방식
public class ObjectWithValue{
    private int value;

    public void synchronized incrementValue(){
        ++ value;
    }

    public in getValue(){
        return value;
    }
}
```
```java
// 새로운 방식
public class ObjectWithValue{
    private AtomicInteger value = new AtomicInteger(0);

    public void incrementValue(){
        value.incrementAndGet();
    }

    public in getValue(){
        return value.get();
    }
}
```
기본 유형이 아니라 객체를 사용했다.  
++ 연산자가 아니라 incrementAndGet()를 사용하지만, 이전 코드보다 거의 항상 빠르다.  
이유는 현대 프로세서는 흔히 CAS(낙관적 잠금 개념과 유사)라 불리는 연산을 지원하기 때문이다.  
synchronized 키워드는 언제나 락(비관적 잠금)을 걸지만, Atomic은 스레드가 같은 값을 수정해 문제를 일으키는 상황이 그리 잦지 않다는 가정에서 출발하여 충돌이 발생했는지를 효율적으로 감지해 갱신이 성공할 때까지 재차 시도한다.  
많은 스레드가 경쟁하는 상황이라도 락을 거는 쪽보다 문제를 감지하는 쪽이 거의 항상 더 효율적이다.  

### 다중 스레드 환경에서 안전하지 않은 클래스 <a name = "11"></a>
다중 스레드 환경에서 안전하지 않은 클래스의 예시로는 다음과 같다.
+ SimpleDateFormat
+ 데이터베이스 연결
+ java.util 컨테이너 클래스
+ 서블릿

참고로 몇명 Collection 클래스는 다중 스레드에서 안전한 메서드를 제공하지만 그런 메서드 여럿을 호출하는 작업은 스레드에서 안전하지 않다.  
예를 들면 HashTable은 동기화 메서드를 제공한다.
```java
if(!hashTable.containsKey(somKey)){
    hashTable.put(someKey, new SomeValue());
}
```
언뜻보면 괜찮아보이지만 다른 스레드가 containsKey와 put 사이에 끼어들어 HashTable에 값을 추가할지도 모른다.  
해별방안은 여러 가지다. 
```java
// HashTable 잠그기
synchronized(map){
    if(!map.containsKey(somKey)){
        map.put(key,value);
    }
}

// 객체로 감싸서 다른 API 사용하기
public class WrappedHashTable<K,V>{
    private Map<K,V> map = new Hashtable<K,V>();

    public synchronized void putIfAbsent(K key, V value){
        if(!map.containsKey(somKey)){
            map.put(key,value);
        }
    }
}

// 스레드에 안전한 집합 클래스 메서드 사용하기
ConcurrentHashMap<Integer, String> map = new ConcurrentHashMap<>();
map.putIfAbsent(key,value);
```


<br>

## 실행 모델을 이해하라 <a name = "12"></a>
기본 용어부터 이해하자  

Name|Description
---|---
한정된 자원|다중 스레드 환경에서 사용하는 자원으로, 크기나 숫자가 제한적이다. 데이터베이스 연결, 길이가 일정한 읽기/쓰기 버퍼 등이 예시이다.
상호 배제|한 번에 한 스레드만 공유 자료나 공유 자원을 사용할 수 있는 경우를 가리킨다.
기아|한 스레드나 여러 스레드가 굉장히 오랫동안 혹은 영원히 자원을 기다린다.
데드락|여러 스레드가 서로 끝나기를 기다린다.
라이브락|락을 거는 단계에서 각 스레드가 서로를 방해한다.

### 생산자-소비자 <a name = "13"></a>
한 개 이상의 생산자가 생산한 작업물을 버퍼 혹은 큐에 넣는다.  
한 개 이상의 소비자가 버퍼 혹은 큐에서 작업물을 습득, 작업을 마친다.  
생산자와 소비자 사이에 있는 큐는 __한정된 자원__ 이다.  
따라서 생산자는 큐에 남는 공간이 생길 때까지, 소비자는 큐에 작업물이 하나라도 생길 때까지 기다려야 한다.  
큐를 통한 생산자와 소비자간의 조율에는 둘 사이의 시그널이 필요하다.  
생산자는 큐에 작업물을 넣고 소비자에게 "큐가 비어있지 않다"는 신호를 보내고 소비자는 큐에서 작업물을 꺼낸 후 "큐가 가득차 있지 않다"는 신호를 보낸다.  
따라서 잘못하면 생산자와 소비자 모두 진행이 가능함에도 동시에 서로의 시그널을 기다릴 가능성이 존재한다.  

### 읽기-쓰기 <a name = "14"></a>
읽기 스레드를 위한 주된 정보원으로 공유 자원을 사용하지만, 쓰기 스레드가 이 공유자원을 이따금 갱신한다고 하자.  
이 경우 처리율이 문제의 핵심이다.  
처리량을 강조해 읽기 스레드가가 상대적인 우선권을 가지게 되면 읽기 작업이 계속될 경우 쓰기 스레드는 기아 상태에 빠진다.  
반면, 쓰기 스레드에 우선권을 주어 쓰기 스레드가 계속 이어지면 읽기 스레드도 기아 상태에 빠진다.  
양쪽에 균형을 잡으면서 동시 갱신 문제를 피하는 해법이 필요하다.  

### 식사하는 철학자들 <a name = "15"></a>
원탁을 둘러싼 여러 명의 철학자들이 있다.  
각 철학자의 왼쪽에 포크가 놓여 있으며 테이블의 중앙에 큰 스파게티 한 그릇이 놓여 있다.  
그들은 배가 고파지면 그들은 자신의 양쪽에 놓여 있는 포크 2개를 잡고 스파게티를 먹는다.  
철학자는 포크 2개가 있어야만 스파게티를 먹을 수 있다.  
그렇지 않다면 옆 사람이 포크를 다 사용하기 전까지 기다려야 한다.  
스파게티를 먹은 철학자는 다시 배가 고파질 때까지 포크를 놓고 있게 된다.  
위 상황에서 철학자를 스레드로, 포크를 공유 자원으로 바꾸게 되면 이는 자원을 놓고 경쟁하는 프로세스와 비슷한 상황이 된다.  
잘 설계되지 않은 시스템은 deadlock, livelock, 처리량 문제, 효율성 저하 문제에 맞닥뜨리기 쉽다.  
<br>

당신이 맞닥뜨릴 대부분의 동시성 관련 문제들은 바로 위에서 언급한 세 가지 문제의 변형일 가능성이 높다.  
이 알고리즘들을 공부하고 스스로 해법을 작성함으로써 이와 같은 문제들을 직면하더라도 의연하게 대처할 수 있도록 하자.  

<br>

## 동기화하는 메서드 사이에 존재하는 의존성을 이해하라 <a name = "16"></a>
동기화하는 메서드 사이에 의존성이 존재하면 동시성 코드에 찾아내기 어려운 버그가 생긴다.  
자바 언어는 개별 메서드를 보호하는 synchronized 개념을 지원한다.  
하지만 클래스 하나에 synchronized 된 메서드가 두 개 이상 존재하면 구현이 올바른지 다시 확인해봐야 한다.  
__권장 사항 : 공유 객체 하나에는 메서드 하나만 사용하라.__  
위 권장 사항을 따를 수 없다면 다음을 고려하라.  
+ 클라이언트에서 잠금
    - 클라이언트에서 첫 번째 메서드를 호출하기 전에 서버를 잠그고 마지막 메서드를 호출할 때까지 잠금을 유지한다.
+ 서버에서 잠금
    - 서버에다 서버를 잠그고 모든 메서드를 호출한 후 잠금을 해제하는 메서드를 구현하고 클라이언트가 이 메서드를 호출한다.
+ 연결(adapted) 서버
    - 잠금을 수행하는 중간 단계를 생성한다. 서버에서 잠금과 유사하지만 원래 서버를 변경하지 않는다.

```java
/*  문제가 되는 상황 */

public class IntegerIterator implements Iterator<Integer> {
    private Integer nextValue = 0;
    
    public synchronized boolean hasNext() {
        return nextValue < 100000;
    }
    
    public synchronized Integer next() {
        if (nextValue == 100000)
            throw new IteratorPastEndException();
        return nextValue++;
    }
    
    public synchronized Integer getNextValue() {
        return nextValue;
    }
}

// Shared Resource
IntegerIterator iterator = new IntegerIterator();

// Threaded-Code
while(iterator.hasNext()) {
    // nextValue가 99999인 상황에서 두 스레드에서 순차적으로 while(iterator.hasNext())를 호출하게 되면
    // 두 스레드 모두 while문 안으로 진입하게 된다. 이는 예상되지 않은 결과이다.
    int nextValue = iterator.next();
    // do something with nextValue
}
```
```java
/* 해결책1 : Client-Based Locking */

// Shared Resource
IntegerIterator iterator = new IntegerIterator();

// Threaded-Code
while (true) {
    int nextValue;
    //  사용하는 클라이언트 입장에서 메서드 호출하기 전에 자원을 잠가버린다.
    synchronized (iterator) {
        if (!iterator.hasNext())
            break;
        nextValue = iterator.next();
    }
    doSometingWith(nextValue);
}
```
```java
/* 해결책 2 : Server-Based Locking */

public class IntegerIteratorServerLocked {
    private Integer nextValue = 0;
    
    public synchronized Integer getNextOrNull() {
        if (nextValue < 100000)
            return nextValue++;
        else
            return null;
    }
}

// Shared Resource
IntegerIterator iterator = new IntegerIterator();

// Threaded-Code
// hasNext 대신 모든 작업을 처리하고 해제하는 메서드 사용
while (true) {
    Integer nextValue = iterator.getNextOrNull();
    if (next == null)
        break;
    // do something with nextValue
}
```
```java
/* 해결책 3 : Adapted Server */

public class ThreadSafeIntegerIterator {
    private IntegerIterator iterator = new IntegerIterator();
    
    // 기존 코드는 synchronized를 해제하고 중간 클래스에서 synchronized로 동기화
    public synchronized Integer getNextOrNull() {
        if(iterator.hasNext())
            return iterator.next();
        return null;
    }
}

// Threaded-Code는 위 Code 2-3과 동일
```

<br>

## 동기화하는 부분을 작게 만들어라 <a name = "17"></a>
자바에서 synchronized 키워드를 사용하면 락을 설정한다.  
락은 스레드를 지연시키고 부하를 가중키지만, 임계영역은 반드시 보호해야 한다.  
따라서 임계영역 수를 최대한 줄이도록 한다.  

<br>

## 올바른 종료 코드는 구현하기 어렵다 <a name = "18"></a>
영구적으로 돌아가는 시스템을 구현하는 방법과 잠시 돌다 깔끔하게 종료하는 시스템을 구현하는 방법은 다르고, 깔끔하게 종료하는 코드는 올바로 구현하기 어렵다.  
가장 흔히 발생하는 문제가 절대 오지 않는 시그널을 기다리는 데드락이다.  
예를 들어, 부모 스레드가 자식 스레드를 여러 개 만든 후 모두가 끝나기를 기다렸다가 자원을 해제하고 종료하는 시스템이 있다고 가정하자.  
만약 스레드 중 하나가 데드락에 걸렸다면 부모 스레드는 영원히 기다리고 시스템은 영원히 종료하지 못한다.  
__권장 : 종료 코드를 개발 초기부터 고민하고 동작하게 초기부터 구현하라. 생각보다 오래 걸린다. 생각보다 어려우므로 이미 나온 알고리즘을 검토하라.__  

<br>

## 스레드 코드 테스트하기 <a name = "19"></a>
테스트가 정확성을 보장하지 않음에도 불구하고 충분한 테스트는 위험을 낮춘다.  
스레드 하나인 프로그램은 지금까지 한 말이 모두 옳으나 멀티 스레드 상황에서는 급격하게 복잡해진다.  
__권장사항 : 문제를 노출하는 테스트 케이스를 작성하고 설정과 부하를 바꿔가며 자주 테스트하라. 테스트가 실패하면 원인을 추적하고 다시 돌려라. 다시 돌렸더니 통과하더라라는 이유로 그냥 넘어가면 절대 안 된다.__  
고려할 사항이 아주 많다는 뜻으로 지금부터 나오는 지침들을 기억하자.  

### 말이 안되는 실패는 잠정적인 스레드 문제로 취급하라 <a name = "20"></a>
다중 스레드 코드는 때때로 말이 안되는 오류를 일으킨다.  
버그는 수천, 수백만 번에 한 번씩 드러나기도 하기 때문에 개발자는 직관적으로 이해하기 어렵다.  
그래서 대다수가 일회성 문제로 치부하고 무시하는데 이 행위가 계속되면 잘못된 코드 위에 계속 코드가 쌓인다.  
__권장 사항 : 시스템 실패를 일회성이라 치부하지 말아라.__  

### 다중 스레드를 고려하지 않은 순차 코드부터 제대로 돌게 만들자. <a name = "21"></a>
일반적인 방법으로, 스레드가 호출하는 POJO를 만든다.  
POJO는 스레드를 모른다. 따라서 스레드 환경 밖에서 테스트가 가능하다.  
__권장사항 : 스레드 환경 밖에서 생기는 버그와 스레드 환경에서 생기는 버그를 동시에 디버깅하지 마라. 먼저 스레드 환경 밖에서 코드를 올바로 돌려라.__  

### 다중 스레드를 쓰는 코드 부분을 다양한 환경에 쉽게 끼워 넣을 수 있게 스레드 코드를 구현하라. <a name = "22"></a>
+ 단일, 다중 스레드에서 실행하거나 실행중 스레드 수를 바꿔본다.
+ 스레드 코드를 실제 환경이나 테스트 환경에서 돌려본다.
+ 테스트 코드를 빨리, 천천히, 다양한 속도로 돌려본다.
+ 반복 테스트가 가능하도록 테스트 케이스를 작성한다.

### 다중 스레드를 쓰는 코드 부분을 상황에 맞게 조율할 수 있게 작성하라 <a name = "23"></a>
스레드 관련 코드의 적절한 균형을 맞추는 작업은 보통 시행착오를 필요로 한다.  
여러 환경에서 시스템의 퍼포먼스를 테스트할 수 있는 방법을 개발 초기에 강구하라.  
실행할 스레드 갯수를 쉽게 변경할 수 있게 작성하라.  
이를 시스템이 동작하는 도중에 변경할 수 있게 하는 것을 고려해 보라.  
처리량과 시스템 활용도를 기준으로 스스로를 조정할 수 있게 하는 것을 고려해 보라.  

### 프로세서 수보다 많은 스레드를 돌려보라 <a name = "24"></a>
시스템이 스레드를 스와핑할 때도 문제가 발생한다.  
스와핑을 일으키려면 프로세서 수보다 많은 스레드를 돌린다.  
스와핑이 잦을수록 임계영역을 빼먹은 코드나 데드락을 일으키는 코드를 찾기 쉬워진다.  

### 다른 플랫폼에서도 돌려보라 <a name = "25"></a>
운영체제마다 스레드를 처리하는 정책이 달라 결과가 달라질 수 있다.  
따라서 코드가 돌아갈 가능성이 있는 플랫폼 전부에서 테스트를 수행해야 마땅하다.  

### 코드에 보조 코드를 넣어 돌려라. 강제로 실패를 일으키게 해보라 <a name = "26"></a>
스레드 관련 문제는 수많은 실행 경로중 얼마 안되는 확률로 발생하기 때문에 드물게 발생하며 재현하기 어렵다.  
보조 코드를 추가해 코드가 실행되는 순서를 바꿔주면 버그가 드러날 가능성이 높아진다.  
코드에 보조 코드를 추가하는 방법은 두 가지다.  

#### 직접 구현하기 
코드에다 직접 wait(), sleep(), yield(), priority()함수를 추가하여 실행 경로를 변경함으로써 코드의 문제를 발견하는 방식이다.
```java
public synchronized String nextUrlOrNull() {
    if(hasNext()) {
        String url = urlGenerator.next();
        
        // inserted for testing.
        Thread.yield();

        updateHasNext();
        return url;
    }
    return null;
}
```
yield() 메서드를 호출함으로써 코드의 실행 순서를 변경할 수 있다.  
만약 위 코드에서 문제가 발생한다면 이는 yield()를 추가해 생긴 문제가 아니라 이미 존재하던 문제를 명백히 만든 것 뿐이다.  
하지만 이 방법에는 문제가 있다.  
+ 보조 코드의 삽입 위치를 직접 찾아야 한다.
+ 어떤 함수를 어디에서 호출해야 적당한지 어떻게 알까?
+ 배포 환경에 보조 코드를 그대로 남겨두면 성능이 저하된다.
+ 무작위 적이라 사실상 드러나지 않은 확률이 더 높다.

#### 자동화
보조 코드를 자동으로 추가하려면 AOF, CGLIB, ASM 등과 같은 도구를 사용한다.
```java
public class ThreadJigglePoint {
    public static void jiggle() { }
}

public synchronized String nextUrlOrNull() {
    if(hasNext()) {
        ThreadJiglePoint.jiggle();
        String url = urlGenerator.next();
        ThreadJiglePoint.jiggle();
        updateHasNext();
        ThreadJiglePoint.jiggle();
        return url;
    }
    return null;
}
```
ThreadJiglePoint 클래스를 두 가지로 구현하면 편리하다.  
하나는 jiggle() 메서드를 비워두고 배포환경에서 사용하고 하나는 무작위로 nop, sleep, yield 등을 넣어두고 테스트 환경에서 사용한다.  
단순한 방법이긴 하지만 좀 더 복잡한 도구를 사용하기 어렵다면 합리적인 대안으로 나쁘지 않다.  
IBM이 개발한 ConTest라는 도구가 있는데 유사하게 동작하지만 좀 더 복잡하다.  
코드를 흔드는(jiggle) 이유는 스레드를 매번 다른 순서로 실행하기 위해서이고 이는 오류가 드러날 확률을 크게 높여준다.  
__권장사항 : 흔들기 기법을 사용해 오류를 찾아내라__  
<br>

## 결론 <a name = "27"></a>
---
다중 스레드 코드는 올바로 구현하기 어렵고, 간단했던 코드는 여러 스레드와 공유 자원이 엮이게 되면 끔찍한 결말을 낳게 된다.  
따라서 다중 스레드 코드를 작성한다면 각별히 깨끗하게 코드를 짜야한다.  
+ 최우선적으로 SRP를 숙지하라.  
    - POJO를 사용해 스레드를 아는 코드와 스레드를 모르는 코드를 분리하고, 스레드 코드를 테스트할 때는 전적으로 스레드만 테스트한다.  
    - 즉, 스레드 코드는 최대한 집약되고 작아야 한다.
+ 동시성 오류를 일으키는 잠정적 원일을 철저히 이해하라.
+ 사용하는 라이브러리와 기본 알고리즘을 이해하라
+ 보호할 코드 영역을 찾아내는 방법과 특정 코드 영역을 잠그는 방법을 이해하라
+ 초반에 드러나지 않는 문제를 일회성으로 치부하지 마라.
+ 시간을 들여 보조 코드를 추가하라.








